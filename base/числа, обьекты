Метод num.toString(base) возвращает строковое представление числа num в системе счисления base
  
  let num = 255;
  alert( num.toString(16) );  // ff
  alert( num.toString(2) );   // 11111111
  
Math.floor
Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.

Math.ceil
Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.

Math.round
Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.

Math.trunc (не поддерживается в Internet Explorer)
Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.

Округление до n знаков после запятой:
  1. Умножить и разделить.
    let num = 1.23456;
    alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
  2. Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.
  Мы можем преобразовать полученное значение в число, используя унарный оператор + или Number(), 
  пример с унарным оператором: +num.toFixed(5).
    let num = 12.34;
    alert( num.toFixed(1) ); // "12.3"
    
isNaN(value) преобразует значение в число и проверяет является ли оно NaN
isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity

parseInt и parseFloat - Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. 
Функция parseInt возвращает целое число, а parseFloat возвращает число с плавающей точкой





Объекты – это ассоциативные массивы с рядом дополнительных возможностей.
Они хранят свойства (пары ключ-значение), где:
  Ключи свойств должны быть строками или символами (обычно строками).
  Значения могут быть любого типа.

Чтобы получить доступ к свойству, мы можем использовать:
  Запись через точку: obj.property.
  Квадратные скобки obj["property"]. Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].

Дополнительные операторы:
  Удаление свойства: delete obj.prop.
  Проверка существования свойства: "key" in obj.
  Перебор свойств объекта: цикл for (let key in obj).

Проверка существования свойства, оператор «in»
  let user = {};
  alert( user.noSuchProperty === undefined ); // true означает "свойства нет"
  
  let user = { name: "John", age: 30 };
  alert( "age" in user ); // true, user.age существует
  alert( "blabla" in user ); // false, user.blabla не существует

Объекты присваиваются и копируются по ссылке. Другими словами, переменная хранит не «значение объекта», а «ссылку» (адрес в памяти) 
на это значение. Поэтому копирование такой переменной или передача её в качестве аргумента функции приводит к копированию этой ссылки, 
а не самого объекта. Все операции с использованием скопированных ссылок (например, добавление или удаление свойств) выполняются с 
одним и тем же объектом.

Чтобы сделать «настоящую копию» (клон), мы можем использовать Object.assign или _.cloneDeep(obj).
  Object.assign(dest, [src1, src2, src3...]) - Аргументы dest, и src1, ..., srcN (может быть столько, сколько нужно) являются 
  объектами, Метод копирует свойства всех объектов src1, ..., srcN в объект dest. То есть, свойства всех перечисленных объектов, 
  начиная со второго, копируются в первый объект. После копирования метод возвращает объект dest.
  let clone = Object.assign({}, user);

То, что мы изучали в этой главе, называется «простым объектом» («plain object») или просто Object.

В JavaScript есть много других типов объектов:

Array для хранения упорядоченных коллекций данных,
Date для хранения информации о дате и времени,
Error для хранения информации об ошибке.
… и так далее.

Для простых объектов доступны следующие методы:
Object.keys(obj) – возвращает массив ключей.
Object.values(obj) – возвращает массив значений.
Object.entries(obj) – возвращает массив пар [ключ, значение].

У объектов нет множества методов, которые есть в массивах, например map, filter и других.
Если мы хотели бы их применить, то можно использовать Object.entries с последующим вызовом Object.fromEntries:
Вызов Object.entries(obj) возвращает массив пар ключ/значение для obj.
На нём вызываем методы массива, например, map.
Используем Object.fromEntries(array) на результате, чтобы преобразовать его обратно в объект.





