СТРОКИ
Свойство length содержит длину строки

Получить символ, который занимает позицию pos, можно с помощью квадратных скобок: [pos]. 
Также можно использовать метод charAt: str.charAt(pos). Первый символ занимает нулевую позицию
  // получаем первый символ
  alert( str[0] ); // H
  alert( str.charAt(0) ); // H

  // получаем последний символ
  alert( str[str.length - 1] ); // o
  
Методы toLowerCase() и toUpperCase() меняют регистр символов

Поиск подстроки
str.indexOf(substr, pos) - ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию, 
на которой располагается совпадение, либо -1 при отсутствии совпадений
Более современный метод str.includes(substr, pos) возвращает true, если в строке str есть подстрока substr, либо false, если нет.

Получение подстроки
str.slice(start [, end]) - Возвращает часть строки от start до (не включая) end
  let str = "stringify";
  // 'strin', символы от 0 до 5 (не включая 5)




МАССИВЫ
let arr = [];
pop - Удаляет последний элемент из массива и возвращает его
push - Добавляет элемент в конец массива
shift - Удаляет из массива первый элемент и возвращает его
unshift - Добавляет элемент в начало массива

Перебор элементов
for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
for (let key in arr) {
  alert( arr[key] ); // Яблоко, Апельсин, Груша
}

arr.splice(index[, deleteCount, elem1, ..., elemN]) - Он начинает с позиции index, удаляет deleteCount элементов и вставляет 
elem1, ..., elemN на их место. Возвращает массив из удалённых элементов.

arr.slice([start], [end]) -Он возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end). 
Оба индекса start и end могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива.

arr.concat(arg1, arg2...) - Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями

forEach - позволяет запускать функцию для каждого элемента массива
  arr.forEach(function(item, index, array) {
    // ... делать что-то с item
  });

arr.indexOf(item, from) ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент, 
в противном случае -1
arr.lastIndexOf(item, from) – то же самое, но ищет справа налево
arr.includes(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен

find и findIndex
  let result = arr.find(function(item, index, array) {
    // если true - возвращается текущий элемент и перебор прерывается
    // если все итерации оказались ложными, возвращается undefined
  });
Если функция возвращает true, поиск прерывается и возвращается item. Если ничего не найдено, возвращается undefined.

filter
  let results = arr.filter(function(item, index, array) {
    // если true - элемент добавляется к результату, и перебор продолжается
    // возвращается пустой массив в случае, если ничего не найдено
  });
  
  let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"}
  ];
  // возвращает массив, состоящий из двух первых пользователей
  let someUsers = users.filter(item => item.id < 3);
  alert(someUsers.length); // 2
  
  
Преобразование массива
map - Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.
  let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
  alert(lengths); // 5,7,6

sort(fn) - Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr

reverse - меняет порядок элементов в arr на обратный. arr.reverse();

split и join 
split - Он разбивает строку на массив по заданному разделителю
  let names = 'Вася, Петя, Маша';
  let arr = names.split(', ');
  for (let name of arr) {
    alert( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася (и другие имена)
  }
  
  let arr = ['Вася', 'Петя', 'Маша'];
  let str = arr.join(';'); // объединить массив в строку через ;
  alert( str ); // Вася;Петя;Маша
