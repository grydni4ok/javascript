В JavaScript все объекты имеют скрытое свойство [[Prototype]], которое является либо другим объектом, либо null.
let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};
rabbit.__proto__ = animal;

Мы можем использовать obj.__ proto__ для доступа к нему (исторически обусловленный геттер/сеттер, есть другие способы, 
которые скоро будут рассмотрены).
Объект, на который ссылается [[Prototype]], называется «прототипом».

Если мы хотим прочитать свойство obj или вызвать метод, которого не существует у obj, тогда JavaScript попытается найти его в прототипе.
Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не сеттер).


Если мы вызываем obj.method(), а метод при этом взят из прототипа, то this всё равно ссылается на obj. Таким образом, методы всегда 
работают с текущим объектом, даже если они наследуются.
// методы animal
let animal = {
  walk() {
    if (!this.isSleeping) {
      alert(`I walk`);
    }
  },
  sleep() {
    this.isSleeping = true;
  }
};
let rabbit = {
  name: "White Rabbit",
  __proto__: animal
};
// модифицирует rabbit.isSleeping
rabbit.sleep();
alert(rabbit.isSleeping); // true
alert(animal.isSleeping); // undefined (нет такого свойства в прототипе)


Цикл for..in перебирает как свои, так и унаследованные свойства. Остальные методы получения ключей/значений работают только с 
собственными свойствами объекта.
